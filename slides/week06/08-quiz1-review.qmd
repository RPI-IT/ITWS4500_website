---
title: "Quiz 1 Review"
subtitle: "Architectural Foundations and System Design"
author: "Jason Kuruzovich"
date: "February 20, 2026"
format:
  revealjs:
    navigation-mode: linear
    mermaid:
        theme: default
    theme: [default, ../../slides-theme.scss]
    logo: ../../static/logos/RPI_Logo_Binary_1_White.png
    footer: "ITWS-4500 | Week 6, Day 2"
    slide-number: true
    transition: slide
    width: 1600
    height: 900
    #chalkboard: true
    code-line-numbers: true
    highlight-style: github
    pdf-separate-fragments: false
---

# Quiz 1 Review {.section-slide background-color="#d6001c"}

Weeks 1-6: Architectural Foundations

## Quiz Format

::: {.callout-note}
### Quiz Details

- **Duration:** 50 minutes
- **Format:** Mixed (multiple choice, short answer, diagrams)
- **Materials:** Closed book, closed notes
- **Coverage:** Weeks 1-6 concepts
:::

## Topics Overview

| Week | Topic | Key Concepts |
|------|-------|--------------|
| 1 | Infrastructure as Code | Docker, Compose, containers |
| 2 | Architecture Foundations | Patterns, decomposition |
| 3 | Layered Architecture | Four layers, dependencies |
| 4 | Component Architecture | React patterns, state |
| 5 | Backend Patterns | Services, middleware, APIs |
| 6 | Data Architecture | Databases, polyglot persistence |

# Week 1: Infrastructure as Code {.section-slide background-color="#d6001c"}

## Containers vs Virtual Machines

```
     Virtual Machines                      Containers
┌─────────────────────────┐     ┌─────────────────────────┐
│ App A │ App B │ App C   │     │ App A │ App B │ App C   │
├───────┼───────┼─────────┤     ├───────┼───────┼─────────┤
│Guest OS│Guest OS│Guest OS│     │  Bins │  Bins │  Bins   │
├───────┴───────┴─────────┤     │  Libs │  Libs │  Libs   │
│       Hypervisor        │     ├─────────────────────────┤
├─────────────────────────┤     │    Container Engine     │
│      Host OS            │     ├─────────────────────────┤
├─────────────────────────┤     │      Host OS            │
│      Hardware           │     ├─────────────────────────┤
└─────────────────────────┘     │      Hardware           │
    GBs, minutes                └─────────────────────────┘
                                    MBs, seconds
```

## Key Container Concepts

| Concept | Definition |
|---------|------------|
| **Image** | Read-only template with instructions to create container |
| **Container** | Running instance of an image |
| **Dockerfile** | Text file with instructions to build an image |
| **Layer** | Each instruction creates a cached layer |
| **Volume** | Persistent storage outside container lifecycle |
| **Registry** | Repository for storing and distributing images |

## Dockerfile Best Practices

```dockerfile
# 1. Use specific tags (not :latest)
FROM node:20-alpine

# 2. Set working directory
WORKDIR /app

# 3. Copy dependency files first (caching)
COPY package*.json ./

# 4. Install dependencies
RUN npm ci --only=production

# 5. Copy source code last (changes most often)
COPY . .

# 6. Don't run as root
USER node

# 7. Document exposed ports
EXPOSE 3000

CMD ["node", "server.js"]
```

**Key insight:** Order instructions from least to most frequently changed

## Docker Compose Concepts

```yaml
services:
  api:
    build: ./api              # Build from Dockerfile
    ports:
      - "4000:4000"          # Host:Container port mapping
    volumes:
      - ./api:/app           # Bind mount for development
      - /app/node_modules    # Anonymous volume
    environment:
      - MONGODB_URI=mongodb://mongo:27017/app
    depends_on:
      - mongo                # Start order

  mongo:
    image: mongo:7           # Use existing image
    volumes:
      - mongo-data:/data/db  # Named volume for persistence

volumes:
  mongo-data:                # Named volume declaration
```

## Review Questions: Week 1

1. What problem do containers solve?

2. Why do we order Dockerfile instructions from least to most frequently changed?

3. What's the difference between a named volume and a bind mount?

4. How do containers in Docker Compose communicate with each other?

5. What does `depends_on` do? Does it wait for the service to be ready?

# Week 2: Architecture Foundations {.section-slide background-color="#d6001c"}

## Architectural Patterns

```{mermaid}
%%| fig-width: 14
mindmap
  root((Patterns))
    Structural
      Layered
      Client-Server
      Microservices
    Behavioral
      Event-Driven
      CQRS
      Pub-Sub
    Data
      Repository
      Unit of Work
```

## Separation of Concerns

Each module should have **one responsibility**:

```
┌──────────────────────────────────────────────────────────┐
│                    Presentation                           │
│              (UI, User Interaction)                       │
├──────────────────────────────────────────────────────────┤
│                    Business Logic                         │
│          (Rules, Validation, Processing)                  │
├──────────────────────────────────────────────────────────┤
│                    Data Access                            │
│            (Database, External APIs)                      │
└──────────────────────────────────────────────────────────┘
```

**Benefits:** Independent development, testing, maintenance

## System Decomposition

**Strategies:**

1. **By Business Capability** - Align with organization
2. **By Subdomain** - Domain-Driven Design approach
3. **By Technical Function** - Frontend, backend, database

**Bounded Context:** A boundary where a particular model applies

```
Sales Context          Shipping Context
┌──────────────┐      ┌──────────────┐
│  Customer    │      │  Recipient   │
│  Order       │      │  Shipment    │
│  Product     │      │  Address     │
└──────────────┘      └──────────────┘
       │                     │
       └────── CustomerID ───┘
```

## Quality Attributes

| Attribute | Description | Trade-off With |
|-----------|-------------|----------------|
| **Performance** | Response time, throughput | Complexity |
| **Scalability** | Handle growth | Simplicity, Cost |
| **Availability** | Uptime, reliability | Consistency |
| **Security** | Protection | Usability |
| **Maintainability** | Ease of change | Performance |

**Key insight:** Every decision involves trade-offs

## Review Questions: Week 2

1. What is separation of concerns and why is it important?

2. Name three architectural patterns and when to use each.

3. What is a bounded context?

4. Why can't you optimize for all quality attributes simultaneously?

5. What should an Architecture Decision Record (ADR) contain?

# Week 3: Layered Architecture {.section-slide background-color="#d6001c"}

## The Four-Layer Model

```
┌─────────────────────────────────────────────────────────────┐
│                    Presentation Layer                        │
│         Components, Views, Controllers, UI Logic             │
├─────────────────────────────────────────────────────────────┤
│                    Application Layer                         │
│            Services, Use Cases, DTOs, Orchestration          │
├─────────────────────────────────────────────────────────────┤
│                      Domain Layer                            │
│       Entities, Business Rules, Domain Services              │
├─────────────────────────────────────────────────────────────┤
│                   Infrastructure Layer                       │
│        Repositories, Database, External Services             │
└─────────────────────────────────────────────────────────────┘
```

## Layer Responsibilities

| Layer | Contains | Depends On |
|-------|----------|------------|
| **Presentation** | UI components, Controllers | Application |
| **Application** | Services, DTOs, Use Cases | Domain |
| **Domain** | Entities, Business Rules | Nothing |
| **Infrastructure** | Repositories, DB Access | Domain (interfaces) |

**The Dependency Rule:** Dependencies point inward (toward domain)

## Dependency Inversion

```javascript
// Domain layer defines interface
interface UserRepository {
  findById(id: string): Promise<User>;
  save(user: User): Promise<void>;
}

// Infrastructure layer implements it
class MongoUserRepository implements UserRepository {
  async findById(id) {
    const doc = await UserModel.findById(id);
    return User.fromDocument(doc);
  }
}

// Application layer uses interface, not implementation
class UserService {
  constructor(private userRepo: UserRepository) {}

  async getUser(id) {
    return this.userRepo.findById(id);
  }
}
```

**Benefit:** Can swap MongoDB for PostgreSQL without changing service

## Review Questions: Week 3

1. What are the four layers and their responsibilities?

2. Why should the Domain layer have no external dependencies?

3. What is the Dependency Rule?

4. How does the Repository pattern enable database flexibility?

5. What belongs in the Application layer vs. the Domain layer?

# Week 4: Component Architecture {.section-slide background-color="#d6001c"}

## Component Categories

| Type | Purpose | Example |
|------|---------|---------|
| **Presentational** | Display data, no logic | `<ProductCard product={...} />` |
| **Container** | Manage state, fetch data | `<ProductListContainer />` |
| **Layout** | Page structure | `<DashboardLayout>` |
| **HOC/Hooks** | Share behavior | `useAuth()`, `withLoading()` |

## State Management Decision Tree

```
Is state used by multiple components?
    │
    ├─ No → useState (local)
    │
    └─ Yes → Are they nearby in tree?
             │
             ├─ Yes → Lift state up / props
             │
             └─ No → Is it complex with many updates?
                     │
                     ├─ No → Context API
                     │
                     └─ Yes → External store (Zustand, Redux)
```

## useState vs useReducer

```javascript
// useState: Simple state
const [count, setCount] = useState(0);
setCount(count + 1);

// useReducer: Complex state with multiple actions
const reducer = (state, action) => {
  switch (action.type) {
    case 'increment': return { ...state, count: state.count + 1 };
    case 'decrement': return { ...state, count: state.count - 1 };
    case 'reset': return { count: 0 };
    default: return state;
  }
};

const [state, dispatch] = useReducer(reducer, { count: 0 });
dispatch({ type: 'increment' });
```

## Context API Pattern

```javascript
// 1. Create context
const AuthContext = createContext();

// 2. Create provider
function AuthProvider({ children }) {
  const [user, setUser] = useState(null);

  const login = async (credentials) => { /* ... */ };
  const logout = () => { /* ... */ };

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

// 3. Create hook
const useAuth = () => useContext(AuthContext);

// 4. Use in components
function Profile() {
  const { user, logout } = useAuth();
  return <button onClick={logout}>Logout {user.name}</button>;
}
```

## Review Questions: Week 4

1. What's the difference between presentational and container components?

2. When should you use Context vs. an external state store?

3. What problem does lifting state up solve?

4. When would you use useReducer instead of useState?

5. How do components communicate (parent→child, child→parent)?

# Week 5: Backend Patterns {.section-slide background-color="#d6001c"}

## RESTful API Design

```
GET    /api/users           # List all
GET    /api/users/:id       # Get one
POST   /api/users           # Create
PUT    /api/users/:id       # Replace
PATCH  /api/users/:id       # Partial update
DELETE /api/users/:id       # Delete

# Nested resources
GET    /api/users/:id/posts
POST   /api/users/:id/posts
```

**Resources are nouns, HTTP methods are verbs**

## HTTP Status Codes

| Code | Meaning | Use Case |
|------|---------|----------|
| 200 | OK | Successful GET, PUT |
| 201 | Created | Successful POST |
| 204 | No Content | Successful DELETE |
| 400 | Bad Request | Invalid input |
| 401 | Unauthorized | Auth required |
| 403 | Forbidden | No permission |
| 404 | Not Found | Resource doesn't exist |
| 500 | Server Error | Unexpected failure |

## Request Flow

```
Request → Router → Middleware → Controller → Service → Repository → DB
                      │
              Auth, Validation,
              Rate Limiting
```

```javascript
// Route
router.post('/users', authenticate, validate(schema), controller.create);

// Controller (HTTP concerns)
async create(req, res, next) {
  const user = await this.userService.create(req.body);
  res.status(201).json({ success: true, data: user });
}

// Service (Business logic)
async create(data) {
  if (await this.repo.findByEmail(data.email)) {
    throw new ConflictError('Email exists');
  }
  return this.repo.create(data);
}
```

## Middleware Pattern

```javascript
// Authentication middleware
function authenticate(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) throw new UnauthorizedError();

  const decoded = jwt.verify(token, SECRET);
  req.user = decoded;
  next();  // Pass to next middleware or handler
}

// Validation middleware
function validate(schema) {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);
    if (error) throw new ValidationError(error.message);
    next();
  };
}

// Error handling middleware (4 params)
function errorHandler(err, req, res, next) {
  res.status(err.statusCode || 500).json({
    success: false,
    error: { message: err.message }
  });
}
```

## Review Questions: Week 5

1. What makes an API RESTful?

2. When should you use 201 vs 200 status code?

3. What's the difference between authentication and authorization?

4. What does the `next()` function do in Express middleware?

5. Why should business logic be in services, not controllers?

# Week 6: Data Architecture {.section-slide background-color="#d6001c"}

## Database Paradigms

| Type | Example | Best For |
|------|---------|----------|
| **Document** | MongoDB | Flexible schema, nested data |
| **Relational** | PostgreSQL | Complex queries, ACID |
| **Key-Value** | Redis | Caching, sessions |
| **Search** | Elasticsearch | Full-text search |

## MongoDB: Embed vs Reference

```javascript
// Embed when:
// - Data accessed together
// - Bounded size
// - Belongs to parent
{
  _id: ObjectId("..."),
  title: "Post",
  comments: [
    { user: "Alice", text: "Great!" },
    { user: "Bob", text: "Thanks!" }
  ]
}

// Reference when:
// - Data accessed independently
// - Unbounded growth
// - Shared across documents
{
  _id: ObjectId("..."),
  title: "Post",
  authorId: ObjectId("...")  // Reference
}
```

## CAP Theorem

```
         Consistency
            /\
           /  \
          / CP \
         /      \
        /________\
   Availability   Partition
                  Tolerance
```

**You can only guarantee 2 of 3 in distributed systems**

- **CP:** Sacrifice availability (MongoDB with majority write)
- **AP:** Sacrifice consistency (Cassandra, DynamoDB)

Network partitions happen → Choose between C and A

## Polyglot Persistence

Using the **right database for each use case**:

```
┌──────────────────────────────────────────────────┐
│                  Application                      │
├──────────┬──────────┬──────────┬────────────────┤
│ MongoDB  │PostgreSQL│  Redis   │ Elasticsearch  │
│          │          │          │                │
│ Profiles │ Orders   │ Sessions │ Product Search │
│ Comments │ Payments │ Cache    │ Logs           │
└──────────┴──────────┴──────────┴────────────────┘
```

**Trade-off:** Optimization vs. operational complexity

## Review Questions: Week 6

1. When should you embed vs reference in MongoDB?

2. What does the CAP theorem state?

3. When would you choose PostgreSQL over MongoDB?

4. What is polyglot persistence and what's the trade-off?

5. Why would you use Redis alongside MongoDB?

# Quick Reference {.section-slide background-color="#d6001c"}

## Key Definitions

| Term | Definition |
|------|------------|
| **Container** | Isolated process with packaged dependencies |
| **Layer** | Horizontal slice of functionality with defined dependencies |
| **Component** | Reusable, self-contained piece of UI |
| **Service** | Business logic coordinator |
| **Repository** | Data access abstraction |
| **Middleware** | Request/response interceptor |
| **ADR** | Document capturing architectural decision |

## Common Patterns Summary

| Pattern | Purpose |
|---------|---------|
| **Layered Architecture** | Separate concerns vertically |
| **Repository** | Abstract data persistence |
| **Middleware** | Cross-cutting concerns |
| **Container/Presenter** | Separate state from display |
| **Context Provider** | Share state without prop drilling |

## Architecture Diagram Template

```
┌─────────────────────────────────────────────────────┐
│                     Client                           │
│  ┌─────────────┐  ┌─────────────┐                  │
│  │ Components  │  │   State     │                  │
│  │ (Presenter) │◄─┤ (Context/   │                  │
│  │             │  │  Store)     │                  │
│  └─────────────┘  └──────┬──────┘                  │
└────────────────────────────┼────────────────────────┘
                             │ HTTP/REST
┌────────────────────────────▼────────────────────────┐
│                     Server                           │
│  Routes → Middleware → Controllers → Services       │
│                                         │           │
│                                    Repositories     │
│                                         │           │
└─────────────────────────────────────────┼───────────┘
                                          │
                              ┌───────────▼───────────┐
                              │      Database         │
                              └───────────────────────┘
```

# Good Luck! {.section-slide background-color="#d6001c"}

## Final Tips

1. **Understand concepts**, not just definitions
2. **Know the trade-offs** for each decision
3. **Practice drawing diagrams** - they may be on the quiz
4. **Review the readings** for each week
5. **Focus on the "why"** not just the "what"

## Questions?

::: {.callout-box}
**Office Hours:** Tuesday 9-11 AM, Pitt 2206

**Email:** kuruzj@rpi.edu

**Appointments:** [bit.ly/jason-rpi](https://bit.ly/jason-rpi)
:::

---

Good luck on Quiz 1!
